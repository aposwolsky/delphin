sig world = [x:term, idx: x => x]


fun gen (d : <[x:term] x => x -> M x => M' x>) :
           <[x:term] [y:term] x => y -> M x => M' y>) = ...


fun gen (d : <[x:term] x => x -> M x => M' x>) :
           <[x:term] [y:term] x => y -> M x => M' y>) = ...


fun dia (d1:<M => M'>) (d2: <M => M''>) 
    : <M' => N> * <M'' => N)

  = case (d1, d2)
     of {b:world} (<b.idx>, <b.idx>) => (<b.idx>, <b.idx>)

      | (<beta R1' R2'>, <beta R1'' R2''>) =>
	      let (S1', S1'') = 
                               {b:world} 
	                       let (S1temp, S2temp) = dia <R1' b.x b.idx> <R1'' b.x b.idx>
		               in
				case (S1temp, S2temp) of
				 (<S1' b.x b.idx>, <S1'' b.x b.idx>) => prev (S1', S1'')

              let (S2', S2'') = dia R2' R2''
              let S1'G = gen S1'
              let S1''G = gen S1''
              in
                 (<S1'G _ _ S2'>, <S1''G _ _ S2''>)



EXPLICIT

fun dia {M'} {M''} {M'''} (d1:<M => M'>) (d2: <M => M''>) 
    : [N] <M' => N> * <M'' => N)

  = case (M,M',M'',d1, d2)
     of {b:world} (_, _, _, <b.idx>, <b.idx>) => (<b.idx>, <b.idx>)

      | (_, _, _, <beta R1' R2'>, <beta R1'' R2''>) =>
	      let <S1', S1''> = 
                               {b:world} 
                               let (_, <S1' b.x b.idx>, <S1'' b.x b.idx>) = 
                                       dia _ _ _ <R1' b.x b.idx> <R1'' b.x b.idx>
                               in
                                   prev <S1', S1''>
	
              let (_, S2', S2'') = dia _ _ _ R2' R2''
              let S1'G = gen S1'
              let S1''G = gen S1''
              in
                 (_, <S1'G _ _ S2'>, <S1''G _ _ S2''>)

