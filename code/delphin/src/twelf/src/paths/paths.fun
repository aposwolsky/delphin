(* Paths, Occurrences, and Error Locations *)
(* Author: Frank Pfenning *)

functor Paths () :> PATHS =
struct

  type pos = int			(* characters, starting at 0 *)
  datatype region = Reg of pos * pos	(* r ::= (i,j) is interval [i,j) *)
  datatype location = Loc of string * region (* loc ::= (filename, region) *)

  type linesInfo = pos list
  fun posToLineCol' (linesInfo, i) =
      let fun ptlc (j::js) = if i >= j then (List.length js, i-j)
			     else ptlc js
	    (* first line should start at 0 *)
	    (* nil means first "line" was not terminated by <newline> *)
	    | ptlc (nil) = (0, i)
      in
	ptlc (linesInfo)
      end

  local
    (* !linePosList is a list of starting character positions for each input line *)
    (* used to convert character positions into line.column format *)
    (* maintained with state *)
    (* val linePosList = ref nil : pos list ref *)
    val linePosListRef = ref (ref nil) : pos list ref ref

    (* ABP:  Updated to contain a collection of linePosList indexed by filename *)
    val linePosListCollection : (string * (pos list ref)) list ref = ref [("", !linePosListRef)]
  in
    fun resetLines (filename) = 
           let
	     val linePosList = ref nil
	     val _ = linePosListRef := linePosList
	     val _ = linePosListCollection := ((filename, linePosList) :: !linePosListCollection)
	   in
	     ()
	   end
    fun newLine (i) = (!linePosListRef) := i::(!(!linePosListRef))
    fun getLinesInfo () = !(!linePosListRef)

    fun restoreLinesInfo (l) = (!linePosListRef) := l
    (* posToLineCol (i) = (line,column) for character position i *)
    fun posToLineCol (i) = posToLineCol' (!(!linePosListRef), i)


    fun getLinesInfoByFileName' (filename, []) = !(!linePosListRef) (* if not found, just use the currently
								     * selected linePosList *)
      | getLinesInfoByFileName' (filename, (name, linePosList)::l)
                       = if (filename = name) then !linePosList else getLinesInfoByFileName'(filename, l)
    fun getLinesInfoByFileName (filename) = getLinesInfoByFileName' (filename, !linePosListCollection)
  end

  (* join (r1, r2) = r
     where r is the  smallest region containing both r1 and r2
  *)
  fun join (Reg (i1, j1), Reg (i2, j2)) = Reg (Int.min (i1, i2), Int.max (j1, j2))

  (* The right endpoint of the interval counts IN RANGE *)
  fun posInRegion (k, Reg (i,j)) = i <= k andalso k <= j

  fun lineColToString (line,col) =
      Int.toString (line+1) ^ "." ^ Int.toString (col+1)

  (* toString r = "line1.col1-line2.col2", a format parsable by Emacs *)
  fun toString (Reg (i,j)) =
        lineColToString (posToLineCol i) ^ "-"
	^ lineColToString (posToLineCol j)

  (* wrap (r, msg) = msg' which contains region *)
  fun wrap (r, msg) = (toString r ^ " Error: \n" ^ msg)

  (* wrapLoc ((loc, r), msg) = msg' which contains region and filename
     This should be used for locations retrieved from origins, where
     the region is given in character positions, rather than lines and columns
  *)
  fun wrapLoc0 (Loc (filename, Reg (i,j)), msg) =
         filename ^ ":" ^ Int.toString (i+1) ^ "-" ^ Int.toString (j+1)
	 ^ " " ^ "Error: \n" ^ msg

  (* wrapLoc' ((loc, r), linesInfo, msg) = msg'
     like wrapLoc, but converts character positions to line.col format based
     on linesInfo, if possible
  *)
  fun wrapLoc' (Loc (filename, Reg (i,j)), SOME(linesInfo), msg) =
      let
	val lcfrom = posToLineCol' (linesInfo, i)
	val lcto = posToLineCol' (linesInfo, j)
	val regString = lineColToString (lcfrom) ^ "-" ^ lineColToString (lcto)
      in
	filename ^ ":" ^ regString ^ " " ^ "Error: \n" ^ msg
      end
    | wrapLoc' (loc, NONE, msg) = wrapLoc0 (loc, msg)

  fun wrapLoc (loc as Loc (filename, _), msg) =
        wrapLoc' (loc, SOME (getLinesInfoByFileName(filename)), msg)

  (* Paths, occurrences and occurrence trees only work well for normal forms *)
  (* In the general case, regions only approximate true source location *)

  (* Follow path through a term to obtain subterm *)

  datatype Path =
     Label of Path			(* [x:#] U or {x:#} V *)
   | Body of Path			(* [x:V] # or {x:V} # *)
   | Head				(* # @ S, term in normal form *)
   | Arg of int * Path			(* C @ S1; ...; #; ...; Sn; Nil *)
   | Here				(* #, covers Uni, EVar, Redex(?) *)

  (* Occurrences: paths in reverse order *)
  (* could also be: type occ = path -> path *)
  datatype occ =
      top
    | label of occ
    | body of occ
    | head of occ
    | arg of int * occ

  (* Occurrence trees for expressions and spines *)
  (* Maps occurrences to regions *)
  (* Simple-minded implementation *)
  (* A region in an intermediate node encloses the whole expression *)
  datatype occExp =			(* occurrences in expressions *)
      leaf of region			(* _ or identifier *)
    | bind of region * occExp option * occExp (* [x:vOpt] u or {x:vOpt} v' *)
    | root of region * occExp * int * int * occSpine (* h @ s, # of implicit arguments, # of arguments actually input (as opposed to generated by eta-expansion) *)
  and occSpine =			(* occurrences in spines *)
      app of occExp * occSpine		(* u;s *)
    | nils				(* nil *)

  (* occToPath (occ, p) = p'(p) and occ corresponds to p' *)
  fun occToPath (top, path) = path
    | occToPath (label(occ), path) = occToPath (occ, Label(path))
    | occToPath (body(occ), path) = occToPath (occ, Body(path))
    | occToPath (head(occ), path) =
      (* path = Here by invariant *)
        occToPath (occ, Head)
    | occToPath (arg(n,occ), path) = occToPath (occ, Arg(n,path))

  datatype occConDec =			(* occurrence tree for constant declarations *)
      dec of int * occExp               (* (#implicit, v) in c : V *)
    | def of int * occExp * occExp option
					(* (#implicit, u, v) in c : V = U *)

  (* val posToPath : occExp -> pos -> Path *)
  (* posToPath (u, k) = p
     where p is the path to the innermost expression in u enclosing position i.

     This includes the position immediately at the end of a region [i,j).
     For example, in "f (g x) y",
     0,1 => "f"
     2   => "(g x)"
     3,4 => "g"
     5,6 => "x"
     8,9 => "y"
  *)
  fun posToPath u k =
      let
          (* local functions refer to k but not u *)
	  fun inside (leaf r) = posInRegion (k, r)
	    | inside (bind (r, _, _)) = posInRegion (k, r)
	    | inside (root (r, _, _, _, _)) = posInRegion (k, r)

	  fun toPath (leaf (Reg (i,j))) = Here (* check? mark? *)
	    | toPath (bind (Reg (i,j), NONE, u)) =
              if inside u then Body (toPath u)
	      else Here
	    | toPath (bind (Reg (i,j), SOME(u1), u2)) =
	      if inside u1 then Label (toPath u1)
	      else if inside u2 then Body (toPath u2)
		   else Here
	    | toPath (root (Reg (i,j), h, imp, actual, s)) =
	      if inside h then Head
	      else (case toPathSpine (s, 1)
		      of NONE => Here
		       | SOME(n, path) => Arg (n+imp, path))
	  (* in some situations, whitespace after subexpressions *)
          (* might give a larger term than anticipated *)
	  and toPathSpine (nils, n) = NONE
	    | toPathSpine (app(u,s), n) =
	      if inside u then SOME(n, toPath u)
	      else toPathSpine (s, n+1)
      in
	toPath u
      end

  (* toRegion (u) = r, the region associated with the whole occurrence tree u *)
  fun toRegion (leaf r) = r
    | toRegion (bind (r, _, _)) = r
    | toRegion (root (r, _, _, _, _)) = r

  (* toRegionSpine (s, r) = r', the join of all regions in s and r *)
  fun toRegionSpine (nils, r) = r
    | toRegionSpine (app (u, s), r) =
        join (toRegion u, toRegionSpine (s, r))	(* order? *)

  (* pathToRegion (u, p) = r,
     where r is the region identified by path p in occurrence tree u
  *)
  fun pathToRegion (u, Here) = toRegion u
    | pathToRegion (bind (r, NONE, u), Label(path)) =
      (* addressing implicit type label returns region of binder and its scope *)
      r
    | pathToRegion (bind (r, SOME(u1), u2), Label(path)) =
        pathToRegion (u1, path)
    | pathToRegion (bind (r, _, u), Body(path)) =
	pathToRegion (u, path)
    | pathToRegion (root (r, _, _, _, _), Label(path)) =
        (* addressing binder introduced as the result of eta expansion
           approximate as the eta-expanded root *)
        r
    | pathToRegion (u as root _, Body(path)) =
        (* bypassing binder introduced as the result of eta expansion *)
        pathToRegion (u, path)
    | pathToRegion (root (r, h, imp, actual, s), Head) = toRegion h
    | pathToRegion (root (r, h, imp, actual, s), Arg (n, path)) =
      if n <= imp
	then (* addressing implicit argument returns region of head *)
	     toRegion h
      else if n-imp > actual
        then (* addressing argument created by eta expansion
                approximate by the whole root *)
             r
      else pathToRegionSpine (s, n-imp, path)
    | pathToRegion (leaf (r), _) = r	(* possible if leaf was _ (underscore) *)
    (* other combinations should be impossible *)
  and pathToRegionSpine (app (u, s), 1, path) =
        pathToRegion (u, path)
    | pathToRegionSpine (app (u, s), n, path) =
	pathToRegionSpine (s, n-1, path)
    (* anything else should be impossible *)

  (* occToRegionExp u occ = r,
     where r is the closest region including occ in occurrence tree u
  *)
  fun occToRegionExp u occ = pathToRegion (u, occToPath (occ, Here))

  fun skipImplicit (0, path) = path
    | skipImplicit (n, Body(path)) =
        skipImplicit (n-1, path)
    | skipImplicit (n, Label(path)) =
	(* implicit argument: approximate as best possible *)
	Here
    | skipImplicit (n, Here) =
	(* addressing body including implicit arguments: approximate by body *)
	Here
    (* anything else should be impossible *)

  (* occToRegionDec d occ = r
     where r is the closest region in v including occ for declaration c : V
  *)
  fun occToRegionDec (dec (n, v)) occ =
      pathToRegion (v, skipImplicit (n, occToPath (occ, Here)))

  (* occToRegionDef1 d occ = r
     where r is the closest region in u including occ for declaration c : V = U
  *)
  fun occToRegionDef1 (def (n, u, vOpt)) occ =
      pathToRegion (u, skipImplicit (n, occToPath (occ, Here)))

  (* occToRegionDef2 d occ = r
     where r is the closest region in V including occ for declaration c : V = U
  *)
  fun occToRegionDef2 (def (n, u, SOME(v))) occ =
      pathToRegion (v, skipImplicit (n, occToPath (occ, Here)))

  (* occToRegionClause d occ = r
     where r is the closest region in V including occ for declaration
     c : V or c : V = U.
  *)
  fun occToRegionClause (d as dec _) occ = occToRegionDec d occ
    | occToRegionClause (d as def (_, _, SOME(_))) occ = occToRegionDef2 d occ

end;  (* functor Paths *)

structure Paths = Paths ();
