Email Delphin to kss@itu.dk

(**) Search/Fix uses of "PopC"!!!!!!!

(**) printing out in "world.fun".. search for print statement..

(**) I do not like LF unification.. pattern substitutions not checked properly. unification
     can make a non-pattern sub. into one and this is not reflected anywhere.

(**) Do not have support of "implicit" parameter functions.
     Such supoprt would require (1) abstract.fun to handle BVarVar

(**) Add more support of "_" in patterns.
     For example, we do not allow patterns of the form ({<x>} _)
     This is NOT equivalent to ({<x>} E) as the E cannot depend on x..
     But it IS equivalent to ({<x>} (E \x)).
     This is analogous to the "_" on the LF level...
     But we should decide how to implement this.



(**)FIXED!!! EVars are raised to everything in the context, this can be a problem in forming
     non-patterns.. For instance:
 sig <exp : type> <lam : (exp -> exp) -> exp> <app : exp -> exp -> exp> ;

	fun foo : <exp> -> <exp> = 
	   fn [<E : exp -> exp>] (<lam ([x:exp] E x)> => (fn ({<x : exp#>} <_> => <lam ([x:exp] x)>)) ({<x : exp#>} foo <E x>));
     This will abstract the pattern variable as dependend on E as well.
     But the programmer can specify it more precisely by writing the pattern as "G x" instead of "_"
     ****
     Solution:  Since EVars contain the entire context, the phase of collection determines
	        which part of the context needs to "really" be abstracted.  This analyzis ALL uses of 
	        the EVar and prunes out identical spines.  That is, it will find the common tail of the spine for
	        all EVars.  For example let's say that EVar r would appear as r@(S,SS) and r@(S2,SS).  As long as
	        everything in SS is in the global context we can just drop the SS.

Things to explain
(1) Scope of FVars are to the nearest "fn"
(2) Tried to add Subordination check to unification... BUG!! 
    The addition caused a bug in the original Twelf test suite.. I don't know why.
    Disabled enhancement... (not sure if it was even necessary in the first place.)

(3) Double Check Addition of BVarVar (look for "Fixed" in Twelf code)

(4) UNSURE Fix.
	In recon-term.fun it was printed out the "types" of mismatched terms.
        Therefore, if you enter nat instead of exp, it would print out "type != type"
        I changed this.. but was it intentional!!!  See recon-term.fun


(5) TWELF BUG::
Try replacing StringTree in recon-term with HashTable and watch what happens!!!
